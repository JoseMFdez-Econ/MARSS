plot(years, y,
xlab="",ylab="log abundance",lwd=2,bty="l")
lines(years,x,type="l",lwd=2,lty=2)
title(paste("simulation ",i) )
}
legend("topright", c("Observed","True"),
lty = c(-1, 2), pch = c(1, -1))
kem = MARSS(y)
kem.params = matrix(NA, nrow=11, ncol=3, dimnames=list(c(paste("sim",1:9),"mean sim","true"),c("kem.U","kem.Q","kem.R")))
kem.states = matrix(NA, nrow=9, ncol=nYr)
for(i in 1:9){
kem = MARSS(y.tss[i,],silent=TRUE)
kem.params[i,] = coef(kem, type="vector")[c(2,3,1)]
kem.states[i,]=kem$states
}
kem.params[10,]=apply(kem.params[1:9,],2,mean)
kem.params[11,]=c(sim.u,sim.Q,sim.R)
kem.params
par(mfrow=c(3,3))
for(i in 1:9){
plot(years, y.tss[i,], xlab="",ylab="index of log abundance",lwd=2,bty="l")
lines(years,x.tss[i,],type="l",lwd=2,lty=2)
lines(years, kem.states[i,], type="l",col=2,lwd=1,lty=1)
title(paste("simulation ",i) )
}
#legend("topright", c("Observed","True","KalmanEM estimate"),lty = c(-1, 2, 1), pch = c(1, -1, -1),col=c(1,1,2))
den.years = years[!is.na(y)] # the non missing years
den.y = y[!is.na(y)] # the non missing counts
den.n.y = length(den.years)
delta.pop = rep(NA, den.n.y-1 ) # population transitions
tau = rep(NA, den.n.y-1 ) # step sizes
for (i in 2:den.n.y ){
delta.pop[i-1] = den.y[i] - den.y[i-1]
tau[i-1] =  den.years[i] - den.years[i-1]
} # end i loop
den91 <- lm(delta.pop ~ -1 + tau)
# note: the "-1" specifies no intercept
den91.u = den91$coefficients
den91.Q = var(resid(den91))
#type ?lm to learn about the linear regression function in R
#form is lm(dependent.var ~ response.var1 + response.var2 + ...)
#type summary(den91) to see other info about our regression fit
par(mfrow=c(1,1))
plot(tau, delta.pop,xlab="time step size (tau)",ylab="population transition size",xlim=c(0,max(tau)),bty="l")
abline(den91,col=2)
den91.params = matrix(NA, nrow=11, ncol=2, dimnames=list(c(paste("sim",1:9),"mean sim","true"),c("den91.U","den91.Q")))
for(i in 1:9){
den.years = years[!is.na(y.tss[i,])] 		# the non missing years
den.yts = y.tss[i,!is.na(y.tss[i,])] 		# the non missing counts
den.n.yts = length(den.years)
delta.pop = rep(NA, den.n.yts-1 ) 	# create a vector to store transitions
tau = rep(NA, den.n.yts-1 )	# create a vector of time step sizes
for (t in 2:den.n.yts ){
delta.pop[t-1] = den.yts[t] - den.yts[t-1]     	# store each transition
tau[t-1] =  den.years[t]-den.years[t-1] 	# the transitions
} # end t loop
den91 <- lm(delta.pop ~ -1+tau) # note: the "-1" specifies no intercept
den91.params[i, ] = c(den91$coefficients, var(resid(den91)))
}
den91.params[10,]=apply(den91.params[1:9,],2,mean)
den91.params[11,]=c(sim.u,sim.Q)
den91.params
sim.u = -0.05   # growth rate
sim.Q = 0.02    # process error variance
sim.R = 0.05    # non-process error variance
nYr= 50         # number of years of data to generate
fracmiss = 0.1  # fraction of years that are missing
init = 7        # log of initial pop abundance (~1100 individuals)
nsim = 9
years = seq(1:nYr)  # col of years
params = matrix(NA, nrow=(nsim+2), ncol=5,
dimnames=list(c(paste("sim",1:nsim),"mean sim","true"),
c("kem.U","den91.U","kem.Q","kem.R", "den91.Q")))
x.ts = matrix(NA,nrow=nsim,ncol=nYr)  # ts w/o measurement error
y.ts = matrix(NA,nrow=nsim,ncol=nYr)  # ts w/ measurement error
for(i in 1:nsim){
x.ts[i,1]=init
for(t in 2:nYr){
x.ts[i,t] = x.ts[i,t-1]+sim.u+rnorm(1,mean=0,sd=sqrt(sim.Q))}
for(t in 1:nYr){
y.ts[i,t] = x.ts[i,t]+rnorm(1,mean=0,sd=sqrt(sim.R))}
missYears = sample(years[2:(nYr-1)], floor(fracmiss*nYr),
replace = FALSE)
y.ts[i,missYears]=NA
#MARSS estimates
kem = MARSS(y.ts[i,], silent=TRUE)
#type=vector outputs the estimates as a vector instead of a list
params[i,c(1,3,4)] = coef(kem,type="vector")[c(2,3,1)]
#Dennis et al 1991 estimates
den.years = years[!is.na(y.ts[i,])]  # the non missing years
den.yts = y.ts[i,!is.na(y.ts[i,])]   # the non missing counts
den.n.yts = length(den.years)
delta.pop = rep(NA, den.n.yts-1 ) # transitions
tau = rep(NA, den.n.yts-1 )       # time step lengths
for (t in 2:den.n.yts ){
delta.pop[t-1] = den.yts[t] - den.yts[t-1] # transitions
tau[t-1] =  den.years[t]-den.years[t-1]    # time step length
} # end i loop
den91 <- lm(delta.pop ~ -1 + tau) # -1 specifies no intercept
params[i,c(2,5)] = c(den91$coefficients, var(resid(den91)))
}
params[nsim+1,]=apply(params[1:nsim,],2,mean)
params[nsim+2,]=c(sim.u,sim.u,sim.Q,sim.R,sim.Q)
print(params,digits=3)
pd = 0.1 #means a 90 percent decline
tyrs = 1:100
xd = -log(pd)
p.ever = ifelse(u<=0,1,exp(-2*u*xd/Q)) #Q=sigma2
for (i in 1:100){
Pi[i] = p.ever * pnorm((-xd+abs(u)*tyrs[i])/sqrt(Q*tyrs[i]))+
exp(2*xd*abs(u)/Q)*pnorm((-xd-abs(u)*tyrs[i])/sqrt(Q*tyrs[i]))
}
#Needs Example 2 to be run first
par(mfrow=c(3,3))
pd = 0.1
te = 100  				# extinction time horizon
tyrs = 1:te
xd = -log(pd)
for(j in c(10,1:8)){
real.ex = matrix(nrow=te)
denn.ex = matrix(nrow=te)
kal.ex  = matrix(nrow=te)
#MARSS
u=params[j,1]
Q=params[j,3]
if(Q==0) Q=1e-4  #just so the extinction calc doesn't choke
p.ever = ifelse(u<=0,1,exp(-2*u*xd/Q))
for (i in 1:100){
if(is.finite(exp(2*xd*abs(u)/Q))){ #Q!=0
part2 = exp(2*xd*abs(u)/Q)*pnorm((-xd-abs(u)* tyrs[i])/sqrt(Q*tyrs[i]))
}else part2=0  #Q=0
kal.ex[i]=p.ever*pnorm((-xd+abs(u)*tyrs[i])/sqrt(Q*tyrs[i]))+ part2
} # end i loop
#Dennis et al 1991
u=params[j,2]
Q=params[j,5]
p.ever = ifelse(u<=0,1,exp(-2*u*xd/Q))
for (i in 1:100){
denn.ex[i] = p.ever*pnorm(( -xd + abs(u)*tyrs[i])/ (sqrt(Q)*sqrt(tyrs[i]))) + exp(2*xd*abs(u)/Q) * pnorm((-xd - abs(u)* tyrs[i]) / (sqrt(Q)*sqrt(tyrs[i])))
} # end i loop
#True
u=sim.u; Q=sim.Q
p.ever = ifelse(u<=0,1,exp(-2*u*xd/Q))
for (i in 1:100){
real.ex[i] = p.ever*pnorm(( -xd + abs(u)*tyrs[i])/ sqrt(Q*tyrs[i])) + exp(2*xd*abs(u)/Q) * pnorm((-xd - abs(u)* tyrs[i]) / sqrt(Q*tyrs[i]))
} # end i loop
#plot it
plot(tyrs,real.ex,xlab="time steps into future",ylab="probability of extinction",ylim=c(0,1),bty="l")
if(j<=8) title(paste("simulation ",j) )
if(j==10) title("average over sims")
lines(tyrs,denn.ex,type="l",col="red",lwd=2,lty=1) #red solid line
lines(tyrs,kal.ex,type="l",col="green",lwd=2,lty=2) #green dashed line
}
legend("bottomright",c("True","Dennis","KalmanEM"),pch=c(1,-1,-1),col=c(1,2,3),lty=c(-1,1,2),lwd=c(-1,2,2),bty="n")
warnings()
#Needs Example 2 to be run first
par(mfrow=c(3,3))
pd = 0.1; xd = -log(pd)   # decline threshold
te = 100; tyrs = 1:te   # extinction time horizon
for(j in c(10,1:8)){
real.ex = denn.ex = kal.ex = matrix(nrow=te)
#MARSS parameter estimates
u=params[j,1];   Q=params[j,3]
if(Q==0) Q=1e-4  #just so the extinction calc doesn't choke
p.ever = ifelse(u<=0,1,exp(-2*u*xd/Q))
for (i in 1:100){
if(is.finite(exp(2*xd*abs(u)/Q))){
sec.part = exp(2*xd*abs(u)/Q)*pnorm((-xd-abs(u)* tyrs[i])/sqrt(Q*tyrs[i]))
}else sec.part=0
kal.ex[i]=p.ever*pnorm((-xd+abs(u)*tyrs[i])/sqrt(Q*tyrs[i]))+sec.part
} # end i loop
#Dennis et al 1991 parameter estimates
u=params[j,2];   Q=params[j,5]
p.ever = ifelse(u<=0,1,exp(-2*u*xd/Q))
for (i in 1:100){
denn.ex[i]=p.ever*pnorm((-xd+abs(u)*tyrs[i])/sqrt(Q*tyrs[i]))+
exp(2*xd*abs(u)/Q)*pnorm((-xd-abs(u)*tyrs[i])/sqrt(Q*tyrs[i]))
} # end i loop
#True parameter values
u=sim.u;   Q=sim.Q
p.ever = ifelse(u<=0,1,exp(-2*u*xd/Q))
for (i in 1:100){
real.ex[i]=p.ever*pnorm((-xd+abs(u)*tyrs[i])/sqrt(Q*tyrs[i]))+
exp(2*xd*abs(u)/Q)*pnorm((-xd-abs(u)*tyrs[i])/sqrt(Q*tyrs[i]))
} # end i loop
#plot it
plot(tyrs, real.ex, xlab="time steps into future",
ylab="probability of extinction", ylim=c(0,1), bty="l")
if(j<=8) title(paste("simulation ",j) )
if(j==10) title("average over sims")
lines(tyrs,denn.ex,type="l",col="red",lwd=2,lty=1)
lines(tyrs,kal.ex,type="l",col="green",lwd=2,lty=2)
}
legend("bottomright",c("True","Dennis","KalmanEM"),pch=c(1,-1,-1),
col=c(1,2,3),lty=c(-1,1,2),lwd=c(-1,2,2),bty="n")
par(mfrow=c(1,1))
CSEGtmufigure(N=nYr, u= sim.u, s2p=sim.Q)
par(mfrow=c(1,1))
CSEGtmufigure(N=50, u=-0.05, s2p=0.02)
warnings()
dat=read.table(datafile, skip=1)
dat=as.matrix(dat)
CSEGriskfigure(dat)
#the data are loaded into package so don't need to be input
#dat=read.table("wilddogs.txt", skip=1)
#dat=as.matrix(dat)
CSEGriskfigure(wilddogs,silent=TRUE)
debug(CSEGriskfigure)
#the data are loaded into package so don't need to be input
#dat=read.table("wilddogs.txt", skip=1)
#dat=as.matrix(dat)
CSEGriskfigure(wilddogs,silent=TRUE)
tyrs
kal.u
library(MARSS)
dir()
Sweave("./manual_files/Case_Study_1.Rnw")
warnings()
remove.packages("MARSS", lib="C:/Program Files/R/R-3.4.3/library")
library(MARSS)
Sweave("./manual_files/Case_Study_1.Rnw")
tools::texi2dvi("Manual.tex")
?texi2dvi
?Sweave
Sweave("./manual_files/test.Rnw")
?pdflatex
dir()
system("pdflatex Manual.tex")
tools::texi2dvi("test.tex")
tools::texi2dvi("test.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
fils
fils[c(9,12)]
created.objs = ls(); created.objs=created.objs[created.objs!="fils"]
rm(list=created.objs)
for(fil in fils[9,12]){
Sweave(here("vignettes", fil))
Stangle(here("vignettes", fil))
created.objs = ls(); created.objs=created.objs[created.objs!="fils"]
rm(list=created.objs)
}
for(fil in fils[c(9,12)]){
Sweave(here("vignettes", fil))
Stangle(here("vignettes", fil))
created.objs = ls(); created.objs=created.objs[created.objs!="fils"]
rm(list=created.objs)
}
warnings()
system("pdflatex Manual.tex")
for(fil in fils[c(12)]){
Sweave(here("vignettes", fil))
Stangle(here("vignettes", fil))
created.objs = ls(); created.objs=created.objs[created.objs!="fils"]
rm(list=created.objs)
}
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
for(fil in fils){
Sweave(here("vignettes", fil))
Stangle(here("vignettes", fil))
created.objs = ls(); created.objs=created.objs[created.objs!="fils"]
rm(list=created.objs)
}
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
system("pdflatex Manual.tex")
bibtex
system("pdflatex Manual.tex")
system("bibtex Manual.tex")
system("bibtex Manual")
system("bibtex Manual.tex")
system("bibtex Manual")
system("pdflatex Manual.tex")
system("bibtex Manual")
fils[11]
for(fil in fils[11]){
Sweave(here("vignettes", fil))
Stangle(here("vignettes", fil))
created.objs = ls(); created.objs=created.objs[created.objs!="fils"]
rm(list=created.objs)
}
warnings()
texfils = c("EMDerivation","Quick_Start","UserGuide","Manual")
for(fil in texfils){
system(paste0("pdflatex ", fil, ".tex"))
system(paste0("bibtex ", fil))
system(paste0("pdflatex ", fil, ".tex"))
}
system("cat Manual.pdf > UserGuide.pdf")
shell("cat Manual.pdf > UserGuide.pdf")
1
setwd("C:/Users/Eli.Holmes/Desktop/MARSS/vignettes")
system("bibtex Manual")
system("pdflatex Manual.tex")
shell("cat Manual.pdf > UserGuide.pdf")
libary(MARSS)
libr\ary(MARSS)
library(MARSS)
?print.marss
?print.marssMLE
matrix(c(1,0,1,0,1,0,0,1,0,1),5,2)
matrix(c(1,1,1,0,0,0,0,0,1,1),5,2)
?MARSS
######################################################################################################   MARSSmcinit function
#   Does a simple MonteCarlo initialization of the EM routine
#   The function uses a number of MARSS utility functions accessed with MARSS:::
#######################################################################################################
MARSSmcinit = function(MLEobj,
control=list(numInits = 500, numInitSteps = 10,
MCbounds=list(B=c(0,1), U=c(-1,1), Q = c(1,1),
Z=c(0,1), A=c(-1,1), R = c(1,1), x0 = c(-1,1) )),
silent=FALSE) {
drawProgressBar = FALSE
if(!silent) { #then we can draw a progress bar
cat("\n"); cat("> Starting Monte Carlo Initializations\n")
prev = MARSS:::progressBar() #this is an internal function to MARSS
drawProgressBar = TRUE
}
MODELobj=MLEobj[["marss"]]
y = MODELobj$data
par.dims=attr(MODELobj,"model.dims")
m = par.dims[["x"]][1]
n = par.dims[["y"]][1]
TT = par.dims[["data"]][2]
## YM matrix for handling missing values
YM=matrix(as.numeric(!is.na(y)),n,TT)
#Make sure the missing vals in y are zeroed out
y[YM==0]=0
free.tmp = MODELobj$free
dim.tmp = list(Z=c(n,m), A=c(n,1), R=c(n,n), B=c(m,m), U=c(m,1), Q=c(m,m), x0=c(m,1))
bounds.tmp = control$MCbounds
init = bestinits = MLEobj$start
bestLL = -1.0e10
# loop over numInits: # of random draws of initial values
for(loop in 1:control$numInits) {
init.loop = init
# Draw random values
en = c("Z", "A", "R", "B", "U", "Q","x0")
for(el in en) {
dim.param = dim.tmp[[el]]
if(!MARSS:::is.fixed(free.tmp[[el]])){ #is.fixed is a utility func in MARSS
bounds.param = bounds.tmp[[el]]
#use the first fixed and free in a temporally varying model; arbitrary
tmp=list(f=MARSS:::sub3D(MODELobj$fixed[[el]],t=1),D=MARSS:::sub3D(MODELobj$free[[el]],t=1))
if(el %in% c("Q", "R")){   # random starts drawn from a wishart dist
if( bounds.param[1] < dim.param[1]){ df=dim.param[1] }else{ df=bounds.param[1] }
S=diag(bounds.param[2],dim.param[1])
#draw a random matrix from wishart
tmp.random = MARSS:::rwishart(df, S)/df
#reapply the sharing and fixed constraints
par.random = solve(t(tmp$D)%*%tmp$D)%*%t(tmp$D)%*%(MARSS:::vec(tmp.random)-tmp$f)
}else{
par.random = matrix(runif(dim(tmp$D)[2], bounds.param[1], bounds.param[2]), dim(tmp$D)[2],1)
if(el %in% c("B")){
tmp.max=max(abs(eigen(par.random,only.values=TRUE)$values))
#rescale to bring the max abs eigenvalues to between 0 and 1
par.random =  par.random/(tmp.max/runif(1,.01,.99))
}
if(el %in% c("x0")){
x0init = init$x0 #where the original start is
x.lo = ifelse(x0init > 0, exp(bounds.param[1])*x0init, exp(bounds.param[2])*x0init)
x.hi = ifelse(x0init > 0, exp(bounds.param[2])*x0init, exp(bounds.param[1])*x0init)
par.random = matrix(runif(dim(tmp$D)[2], x.lo, x.hi), dim(tmp$D)[2],1)
}
}
}else{ par.random=matrix(0,0,1) }
init.loop[[el]] = par.random
}
## Call MARSSkem() with these inits
MLEobj$start = init.loop
MLEobj$control$maxit = control$numInitSteps
MLEobj$control$minit = 1
MLEobj$control$silent = TRUE #don't print convergence information during kem call
MLEobj = MARSSkem(MLEobj)  #get new fit using this init
if(drawProgressBar==TRUE) prev = MARSS:::progressBar(loop/control$numInits, prev)
## Check whether the likelihood is the best observed
## Only use bootstrap param draws where loglike did not go down during numInitSteps
if(MLEobj$logLik > bestLL) {
# update the best initial parameter estimates
bestinits = MLEobj$par
bestLL = MLEobj$logLik
}
} # end numInits loop
return(bestinits)
}
dat = t(harborSeal)
dat = dat[c(2,nrow(dat)),]
fit1=MARSS(dat)
MCinits = MARSSmcinit(fit1, control=list(numInits = 10))
fit2=MARSS(dat, inits=MCinits)
library(MARSS)
dat = t(harborSeal)
dat = dat[c(2,nrow(dat)),]
fit1=MARSS(dat)
MCinits = MARSSmcinit(fit1, control=list(numInits = 10))
fit2=MARSS(dat, inits=MCinits)
letters
letters %in% c("a","b","c")
######################################################################################################   MARSSmcinit function
#   Does a simple MonteCarlo initialization of the EM routine
#   The function uses a number of MARSS utility functions accessed with MARSS:::
#######################################################################################################
MARSSmcinit = function(MLEobj,
control=list(numInits = 500, numInitSteps = 10,
MCbounds=list(B=c(0,1), U=c(-1,1), Q = c(1,1),
Z=c(0,1), A=c(-1,1), R = c(1,1), x0 = c(-1,1) )),
silent=FALSE) {
control.default=list(numInits = 500, numInitSteps = 10, MCbounds=list(B=c(0,1), U=c(-1,1), Q = c(1,1), Z=c(0,1), A=c(-1,1), R = c(1,1), x0 = c(-1,1) ))
if(!is.null(control)){
if(!is.list(control)) stop("MARSSmcinit: control must be a list")
if(any(!(names(control)%in%names(control.default)))) stop(paste("MARSSmcinit: allowed control list elements are", names(control.default)))
control.new=control.default
for(i in names(control)) control.new[[i]]=control[[i]]
control = control.new
}
drawProgressBar = FALSE
if(!silent) { #then we can draw a progress bar
cat("\n"); cat("> Starting Monte Carlo Initializations\n")
prev = MARSS:::progressBar() #this is an internal function to MARSS
drawProgressBar = TRUE
}
MODELobj=MLEobj[["marss"]]
y = MODELobj$data
par.dims=attr(MODELobj,"model.dims")
m = par.dims[["x"]][1]
n = par.dims[["y"]][1]
TT = par.dims[["data"]][2]
## YM matrix for handling missing values
YM=matrix(as.numeric(!is.na(y)),n,TT)
#Make sure the missing vals in y are zeroed out
y[YM==0]=0
free.tmp = MODELobj$free
dim.tmp = list(Z=c(n,m), A=c(n,1), R=c(n,n), B=c(m,m), U=c(m,1), Q=c(m,m), x0=c(m,1))
bounds.tmp = control$MCbounds
init = bestinits = MLEobj$start
bestLL = -1.0e10
# loop over numInits: # of random draws of initial values
for(loop in 1:control$numInits) {
init.loop = init
# Draw random values
en = c("Z", "A", "R", "B", "U", "Q","x0")
for(el in en) {
dim.param = dim.tmp[[el]]
if(!MARSS:::is.fixed(free.tmp[[el]])){ #is.fixed is a utility func in MARSS
bounds.param = bounds.tmp[[el]]
#use the first fixed and free in a temporally varying model; arbitrary
tmp=list(f=MARSS:::sub3D(MODELobj$fixed[[el]],t=1),D=MARSS:::sub3D(MODELobj$free[[el]],t=1))
if(el %in% c("Q", "R")){   # random starts drawn from a wishart dist
if( bounds.param[1] < dim.param[1]){ df=dim.param[1] }else{ df=bounds.param[1] }
S=diag(bounds.param[2],dim.param[1])
#draw a random matrix from wishart
tmp.random = MARSS:::rwishart(df, S)/df
#reapply the sharing and fixed constraints
par.random = solve(t(tmp$D)%*%tmp$D)%*%t(tmp$D)%*%(MARSS:::vec(tmp.random)-tmp$f)
}else{
par.random = matrix(runif(dim(tmp$D)[2], bounds.param[1], bounds.param[2]), dim(tmp$D)[2],1)
if(el %in% c("B")){
tmp.max=max(abs(eigen(par.random,only.values=TRUE)$values))
#rescale to bring the max abs eigenvalues to between 0 and 1
par.random =  par.random/(tmp.max/runif(1,.01,.99))
}
if(el %in% c("x0")){
x0init = init$x0 #where the original start is
x.lo = ifelse(x0init > 0, exp(bounds.param[1])*x0init, exp(bounds.param[2])*x0init)
x.hi = ifelse(x0init > 0, exp(bounds.param[2])*x0init, exp(bounds.param[1])*x0init)
par.random = matrix(runif(dim(tmp$D)[2], x.lo, x.hi), dim(tmp$D)[2],1)
}
}
}else{ par.random=matrix(0,0,1) }
init.loop[[el]] = par.random
}
## Call MARSSkem() with these inits
MLEobj$start = init.loop
MLEobj$control$maxit = control$numInitSteps
MLEobj$control$minit = 1
MLEobj$control$silent = TRUE #don't print convergence information during kem call
MLEobj = MARSSkem(MLEobj)  #get new fit using this init
if(drawProgressBar==TRUE) prev = MARSS:::progressBar(loop/control$numInits, prev)
## Check whether the likelihood is the best observed
## Only use bootstrap param draws where loglike did not go down during numInitSteps
if(MLEobj$logLik > bestLL) {
# update the best initial parameter estimates
bestinits = MLEobj$par
bestLL = MLEobj$logLik
}
} # end numInits loop
return(bestinits)
}
dat = t(harborSeal)
dat = dat[c(2,nrow(dat)),]
fit1=MARSS(dat)
MCinits = MARSSmcinit(fit1, control=list(numInits = 10))
fit2=MARSS(dat, inits=MCinits)
?harborSeals
?harborSeal
harborSeal
?MARSS.dfa
MARSSinfo()
?MARSSinfo
